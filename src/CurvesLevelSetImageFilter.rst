The source code for this section can be found in the file
``CurvesLevelSetImageFilter.cxx``.

WORK IN PROGRESS: THIS WAS TAKEN FROM THE GEODESIC ACTIVE CONTOURS. IT
NEED TO BE REWORKED TO MATCH THE CURVESLEVELSET FILTER.

The use of the {CurvesLevelSetImageFilter} is illustrated in the
following example. The implementation of this filter in ITK is based on
the paper by Caselles . This implementation extends the functionality of
the {ShapeDetectionLevelSetImageFilter} by the addition of a third
avection term which attracts the level set to the object boundaries.

CurvesLevelSetImageFilter expects two inputs. The first is an initial
level set in the form of an {Image}. The second input is a feature
image. For this algorithm, the feature image is an edge potential image
that basically follows the same rules used for the
ShapeDetectionLevelSetImageFilter discussed in
Section {sec:ShapeDetectionLevelSetFilter}. The configuration of this
example is quite similar to the example on the use of the
ShapeDetectionLevelSetImageFilter. We omit most of the redundant
description. A look at the code will reveal the great degree of
similarity between both examples.

    |image| [CurvesLevelSetImageFilter collaboration diagram]
    {Collaboration diagram for the CurvesLevelSetImageFilter applied to
    a segmentation task.} {fig:CurvessCollaborationDiagram}

Figure {fig:CurvessCollaborationDiagram} shows the major components
involved in the application of the CurvesLevelSetImageFilter to a
segmentation task. This pipeline is quite similar to the one used by the
ShapeDetectionLevelSetImageFilter in
section {sec:ShapeDetectionLevelSetFilter}.

The pipeline involves a first stage of smoothing using the
{CurvatureAnisotropicDiffusionImageFilter}. The smoothed image is passed
as the input to the {GradientMagnitudeRecursiveGaussianImageFilter} and
then to the {SigmoidImageFilter} in order to produce the edge potential
image. A set of user-provided seeds is passed to a
{FastMarchingImageFilter} in order to compute the distance map. A
constant value is subtracted from this map in order to obtain a level
set in which the *zero set* represents the initial contour. This level
set is also passed as input to the CurvesLevelSetImageFilter.

Finally, the level set generated by the CurvesLevelSetImageFilter is
passed to a {BinaryThresholdImageFilter} in order to produce a binary
mask representing the segmented object.

Let’s start by including the headers of the main filters involved in the
preprocessing.

::

    [language=C++]
    #include "itkCurvesLevelSetImageFilter.h"

We now define the image type using a particular pixel type and
dimension. In this case the {float} type is used for the pixels due to
the requirements of the smoothing filter.

::

    [language=C++]
    typedef   float           InternalPixelType;
    const     unsigned int    Dimension = 2;
    typedef itk::Image< InternalPixelType, Dimension >  InternalImageType;

In the following lines we instantiate the type of the
CurvesLevelSetImageFilter and create an object of this type using the
{New()} method.

::

    [language=C++]
    typedef  itk::CurvesLevelSetImageFilter< InternalImageType,
    InternalImageType >    CurvesFilterType;
    CurvesFilterType::Pointer geodesicActiveContour =
    CurvesFilterType::New();

For the CurvesLevelSetImageFilter, scaling parameters are used to trade
off between the propagation (inflation), the curvature (smoothing) and
the advection terms. These parameters are set using methods
{SetPropagationScaling()}, {SetCurvatureScaling()} and
{SetAdvectionScaling()}. In this example, we will set the curvature and
advection scales to one and let the propagation scale be a command-line
argument.

::

    [language=C++]
    geodesicActiveContour->SetPropagationScaling( propagationScaling );
    geodesicActiveContour->SetCurvatureScaling( 1.0 );
    geodesicActiveContour->SetAdvectionScaling( 1.0 );

The filters are now connected in a pipeline indicated in
Figure {fig:CurvessCollaborationDiagram} using the following lines:

::

    [language=C++]
    smoothing->SetInput( reader->GetOutput() );
    gradientMagnitude->SetInput( smoothing->GetOutput() );
    sigmoid->SetInput( gradientMagnitude->GetOutput() );

    geodesicActiveContour->SetInput(  fastMarching->GetOutput() );
    geodesicActiveContour->SetFeatureImage( sigmoid->GetOutput() );

    thresholder->SetInput( geodesicActiveContour->GetOutput() );
    writer->SetInput( thresholder->GetOutput() );

The invocation of the {Update()} method on the writer triggers the
execution of the pipeline. As usual, the call is placed in a {try/catch}
block should any errors occur or exceptions be thrown.

::

    [language=C++]
    try
    {
    writer->Update();
    }
    catch( itk::ExceptionObject & excep )
    {
    std::cerr << "Exception caught !" << std::endl;
    std::cerr << excep << std::endl;
    }

Let’s now run this example using as input the image
{BrainProtonDensitySlice.png} provided in the directory {Examples/Data}.
We can easily segment the major anatomical structures by providing seeds
in the appropriate locations. Table {tab:CurvesImageFilterOutput2}
presents the parameters used for some structures.

            Structure & Seed Index & Distance & :math:`\sigma` &
            :math:`\alpha` & :math:`\beta` & Propag. & Output Image
             Left Ventricle & :math:`(81,114)` & 5.0 & 1.0 & -0.5 &
            3.0 & 2.0 & First
             Right Ventricle & :math:`(99,114)` & 5.0 & 1.0 & -0.5 &
            3.0 & 2.0 & Second
             White matter & :math:`(56, 92)` & 5.0 & 1.0 & -0.3 & 2.0
            & 10.0 & Third
             Gray matter & :math:`(40, 90)` & 5.0 & 0.5 & -0.3 & 2.0 &
            10.0 & Fourth

    [Curves segmentation example parameters] {Parameters used for
    segmenting some brain structures shown in
    Figure {fig:CurvesImageFilterOutput2} using the filter
    CurvesLevelSetImageFilter. {tab:CurvesImageFilterOutput2}}

Figure {fig:CurvesImageFilterOutput} presents the intermediate outputs
of the pipeline illustrated in Figure {fig:CurvessCollaborationDiagram}.
They are from left to right: the output of the anisotropic diffusion
filter, the gradient magnitude of the smoothed image and the sigmoid of
the gradient magnitude which is finally used as the edge potential for
the CurvesLevelSetImageFilter.

    |image1| |image2| |image3| |image4| [CurvesLevelSetImageFilter
    intermediate output] {Images generated by the segmentation process
    based on the CurvesLevelSetImageFilter. From left to right and top
    to bottom: input image to be segmented, image smoothed with an
    edge-preserving smoothing filter, gradient magnitude of the smoothed
    image, sigmoid of the gradient magnitude. This last image, the
    sigmoid, is used to compute the speed term for the front
    propagation.} {fig:CurvesImageFilterOutput}

Segmentations of the main brain structures are presented in
Figure {fig:CurvesImageFilterOutput2}. The results are quite similar to
those obtained with the ShapeDetectionLevelSetImageFilter in
Section {sec:ShapeDetectionLevelSetFilter}.

Note that a relatively larger propagation scaling value was required to
segment the white matter. This is due to two factors: the lower contrast
at the border of the white matter and the complex shape of the
structure. Unfortunately the optimal value of these scaling parameters
can only be determined by experimentation. In a real application we
could imagine an interactive mechanism by which a user supervises the
contour evolution and adjusts these parameters accordingly.

    |image5| |image6| |image7| |image8| [CurvesImageFilter
    segmentations] {Images generated by the segmentation process based
    on the CurvesImageFilter. From left to right: segmentation of the
    left ventricle, segmentation of the right ventricle, segmentation of
    the white matter, attempt of segmentation of the gray matter.}
    {fig:CurvesImageFilterOutput2}

.. |image| image:: CurvessCollaborationDiagram1.eps
.. |image1| image:: BrainProtonDensitySlice.eps
.. |image2| image:: CurvesImageFilterOutput1.eps
.. |image3| image:: CurvesImageFilterOutput2.eps
.. |image4| image:: CurvesImageFilterOutput3.eps
.. |image5| image:: CurvesImageFilterOutput5.eps
.. |image6| image:: CurvesImageFilterOutput6.eps
.. |image7| image:: CurvesImageFilterOutput7.eps
.. |image8| image:: CurvesImageFilterOutput8.eps
