The source code for this section can be found in the file
``ImageRegistration10.cxx``.

This example illustrates the use of the image registration framework in
Insight to align two label maps. Common structures are assumed to use
the same label. The registration metric simply counts the number of
corresponding pixels that have the same label.

::

    [language=C++]
    #include "itkImageRegistrationMethod.h"
    #include "itkTranslationTransform.h"
    #include "itkMatchCardinalityImageToImageMetric.h"
    #include "itkNearestNeighborInterpolateImageFunction.h"
    #include "itkAmoebaOptimizer.h"

The transform that will map one image space into the other is defined
below.

::

    [language=C++]
    typedef itk::TranslationTransform< double, Dimension > TransformType;

An optimizer is required to explore the parameter space of the transform
in search of optimal values of the metric. The metric selected does not
require analytical derivatives of its cost function.

::

    [language=C++]
    typedef itk::AmoebaOptimizer       OptimizerType;

The metric will compare how well the two images match each other. Metric
types are usually parameterized by the image types as can be seen in the
following type declaration. The metric selected here is suitable for
comparing two label maps where the labels are consistent between the two
maps. This metric measures the percentage of pixels that exactly match
or mismatch.

::

    [language=C++]
    typedef itk::MatchCardinalityImageToImageMetric<
    FixedImageType,
    MovingImageType >    MetricType;

Since we are registering label maps, we use a
NearestNeighborInterpolateImageFunction to ensure subpixel values are
not interpolated (to labels that do not exist).

::

    [language=C++]
    typedef itk:: NearestNeighborInterpolateImageFunction<
    MovingImageType,
    double          >    InterpolatorType;

::

    [language=C++]
    MetricType::Pointer         metric        = MetricType::New();
    TransformType::Pointer      transform     = TransformType::New();
    OptimizerType::Pointer      optimizer     = OptimizerType::New();
    InterpolatorType::Pointer   interpolator  = InterpolatorType::New();
    RegistrationType::Pointer   registration  = RegistrationType::New();

::

    [language=C++]
    metric->MeasureMatchesOff();

It is usually desirable to fine tune the parameters of the optimizer.
Each optimizer has particular parameters that must be interpreted in the
context of the optimization strategy it implements.

The AmoebaOptimizer moves a simplex around the cost surface. Here we set
the initial size of the simplex (5 units in each of the parameters)

::

    [language=C++]
    OptimizerType::ParametersType
    simplexDelta( transform->GetNumberOfParameters() );
    simplexDelta.Fill( 5.0 );

    optimizer->AutomaticInitialSimplexOff();
    optimizer->SetInitialSimplexDelta( simplexDelta );

We also adjust the tolerances on the optimizer to define convergence.
Here, we used a tolerance on the parameters of 0.25 (which will be a
quarter of image unit, in this case pixels). We also set the tolerance
on the cost function value to define convergence. The metric we are
using returns the percentage of pixels that mismatch. So we set the
function convergence to be 0.1

::

    [language=C++]
    optimizer->SetParametersConvergenceTolerance( 0.25 );  quarter pixel
    optimizer->SetFunctionConvergenceTolerance(0.001);  0.1%

In the case where the optimizer never succeeds in reaching the desired
precision tolerance, it is prudent to establish a limit on the number of
iterations to be performed. This maximum number is defined with the
method {SetMaximumNumberOfIterations()}.

::

    [language=C++]
    optimizer->SetMaximumNumberOfIterations( 200 );

The example was run on two binary images. The first binary image was
generated by running the confidence connected image filter (section
{sec:ConfidenceConnected}) on the MRI slice of the brain. The second was
generated similarly after shifting the slice by 13 pixels horizontally
and 17 pixels vertically. The Amoeba optimizer converged after 34
iterations and produced the following results:

::

    Translation X = 12.5
    Translation Y = 16.77

These results are a close match to the true misalignment.
