In ITK, the {MultiResolutionPyramidImageFilter} can be used to create a
sequence of reduced resolution images from the input image. The
down-sampling is performed according to a user defined multi-resolution
schedule. The schedule is specified as an {Array2D} of integers,
containing shrink factors for each multi-resolution level (rows) for
each dimension (columns). For example,

::

    8 4 4
    4 4 2

is a schedule for a three dimensional image for two multi-resolution
levels. In the first (coarsest) level, the image is reduced by a factor
of 8 in the column dimension, factor of 4 in the row dimension and a
factor of 4 in the slice dimension. In the second level, the image
reduced by a factor of 4 in the column dimension, 4 in the row dimension
and 2 in the slice dimension.

The method {SetNumberOfLevels()} is used to set the number of resolution
levels in the pyramid. This method will allocate memory for the schedule
and generate a default table with the starting (coarsest) shrink factors
for all dimensions set to :math:`(M-1)^2`, where :math:`M` is the
number of levels. All factors are halved for all subsequent levels. For
example, if we set the number of levels to 4, the default schedule is
then:

::

    8 8 8
    4 4 4
    2 2 2
    1 1 1

The user can get a copy of the schedule using method {GetSchedule()},
make modifications, and reset it using method {SetSchedule()}.
Alternatively, a user can create a default table by specifying the
starting (coarsest) shrink factors using the method
{SetStartingShrinkFactors()}. The factors for the subsequent levels are
generated by halving the factor or setting it to one, depending on which
is larger. For example, for a 4 level pyramid and starting factors of 8,
8 and 4, the generated schedule would be:

::

    8 8 4
    4 4 2
    2 2 1
    1 1 1

When this filter is triggered by {Update()}, :math:`M` outputs are
produced where the :math:`m`-th output corresponds to the
:math:`m`-th level of the pyramid. To generate these images, Gaussian
smoothing is first performed using a {DiscreteGaussianImageFilter} with
the variance set to :math:`(s/2)^2`, where :math:`s` is the shrink
factor. The smoothed images are then sub-sampled using a
{ShrinkImageFilter}.
