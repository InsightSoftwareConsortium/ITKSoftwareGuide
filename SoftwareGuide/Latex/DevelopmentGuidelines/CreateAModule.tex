\chapter{How To Create A Module}
\label{chapter:CreateAModule}
\index{module}

The Insight Toolkit is organized into logical units of coherent functionality called
modules. These modules are self-contained in a directory, whose components
are organized into subdirectories with standardized names. A module usually has
dependencies on other modules, which it declares. A module is defined with
CMake scripts that inform the build system of its contents and dependencies.

The modularization effort significantly improves the extensibility of the
toolkit and lowers the barrier to contribution.

Modules are organized into:

\begin{itemize}
  \item The \textbf{top level} directory.

  \item The \textbf{include} directory.

  \item The \textbf{src} directory.

  \item The \textbf{test} directory.

  \item The \textbf{wrapping} directory.
\end{itemize}

This chapter describes how to create a new module. The following sections  are
organized by the different directory components of the module. The chapter
concludes with a section on how to add a third-party library dependency to a
module.

Note that the Insight Toolkit community has adopted a Coding Style guideline
for the sake of consistentcy and readability of the code. Such guideline is
described in Chapter \ref{ch:CodingStyleGuide}.

\section{Name and dependencies}
\label{sec:NameAndDependencies}
\index{module!top level}

The top level directory of a module is used to define a module's name and its
dependencies. Two files are required:

\begin{enumerate}
  \item \code{CMakeLists.txt}
  \item \code{itk-module.cmake}
\end{enumerate}

The information described in these files is used to populate \code{<ModuleName>.cmake}
files in the ITK module registry. The module registry is located
at \code{<ITK build directory>/lib/cmake/\ITKVERSIONMAJORMINOR/Modules/} in a
build tree or
\code{<CMAKE\_INSTALL\_PREFIX>/lib/cmake/\ITKVERSIONMAJORMINOR/Modules/}
in an install tree. These module files declare information about the module
and what is required to use it. This includes its module dependencies, C++ include
directories required to build against it, the libraries to link against, and CMake
code required to use it in a CMake configured project.


\subsection{CMakeLists.txt}

When CMake starts processing a module, it begins with the top level
\code{CMakeLists.txt} file. At a minimum, the \code{CMakeLists.txt} should
contain

\begin{minted}[baselinestretch=1,fontsize=\footnotesize,linenos=false,bgcolor=ltgray]{cmake}
cmake_minimum_required(VERSION 3.10.2 FATAL_ERROR)
cmake_policy(VERSION 3.10.2)

project(MyModule)

set(MyModule_LIBRARIES MyModule)

if(NOT ITK_SOURCE_DIR)
  find_package(ITK REQUIRED)
  list(APPEND CMAKE_MODULE_PATH ${ITK_CMAKE_DIR})
  include(ITKModuleExternal)
else()
  itk_module_impl()
endif()
\end{minted}

where \code{MyModule} is the name of the module.

The CMake variable \code{<module-name>\_LIBRARIES} should be set to the names
of the libraries, if any, that clients of the module need to link. This will be
the same name as the library generated with the \code{add\_library} command in
a module's \code{src} directory, described in further detail in the Libraries
Section~\ref{sec:Libraries}.

The path \code{if(NOT ITK\_SOURCE\_DIR)} is used when developing a module outside of the
ITK source tree, i.e. an External module. An External module can be made
available to the community by adding it to \code{Modules/Remote/*.remote.cmake}
Remote module index in the ITK repository per Section ~\ref{sec:GitRepository}.

The CMake macro \code{itk\_module\_impl} is defined in the file
\code{CMake/ITKModuleMacros.cmake}. It will initiate processing of the
remainder of a module's CMake scripts. The script \code{ITKModuleExternal}
calls \code{itk\_module\_impl} internally.


\subsection{itk-module.cmake}

The \code{itk-module.cmake} is also a required CMake script at the top level
of a module, but this file is used to declare

\begin{enumerate}
  \item The module name.
  \item Dependencies on other modules.
  \item Modules properties.
  \item A description of the module.
\end{enumerate}

In this file, first set a CMake variable with the module's
description followed by a call to the \code{itk\_module} macro, which is
already defined by the time the script is read. For example,
\code{itk-module.cmake} for the \texttt{ITKCommon} module is

\begin{minted}[baselinestretch=1,fontsize=\footnotesize,linenos=false,bgcolor=ltgray]{cmake}
set(DOCUMENTATION "This module contains the central classes of the ITK
toolkit.  They include, basic data structures \(such as Points, Vectors,
Images, Regions\) the core of the process objects \(such as base
classes for image filters\) the pipeline infrastructure classes, the support
for multi-threading, and a collection of classes that isolate ITK from
platform specific features. It is anticipated that most other ITK modules will
depend on this one.")

itk_module(ITKCommon
  ENABLE_SHARED
  PRIVATE_DEPENDS
    ITKDoubleConversion
  COMPILE_DEPENDS
    ITKKWSys
    ITKVNLInstantiation
  TEST_DEPENDS
    ITKTestKernel
    ITKMesh
    ITKImageIntensity
    ITKIOImageBase
  DESCRIPTION
    "${DOCUMENTATION}"
)
\end{minted}

The description for the module should be escaped as a CMake string, and it
should be formatted with Doxygen markup. This description is added to ITK's
generated Doxygen documentation when the module is added to the Remote module
index. The description should describe the purpose and content of the module
and reference an Insight Journal article for further information.

A module name is the only required positional argument to the
\code{itk\_module} macro. Named options that take one or argument are:

\begin{description}
  \item[DEPENDS]          Modules that will be publicly linked to this module.
    The header's used are added to \code{include/*.\{h,hxx\}} files.
  \item[PRIVATE\_DEPENDS] Modules that will be privately linked to this
    module. The header's used are only added to \code{src/*.cxx} files.
  \item[COMPILE\_DEPENDS] Modules that are needed at compile time by this module.
    The header's used are added to \code{include/*\{h,hxx\}} files but there
    is not a library to link against.
  \item[TEST\_DEPENDS]    Modules that are needed by this modules testing executables.
    The header's used are added to \code{test/*.cxx} files.
  \item[DESCRIPTION]      Free text description of the module.
\end{description}

Public dependencies are added to the module's
\code{INTERFACE\_LINK\_LIBRARIES}, which is a list of transitive link
dependencies.  When this module is linked to by another target, the libraries
listed (and recursively, their link interface libraries) will be provided to
the target also. Private dependencies are linked to by this module, but not
added to \code{INTERFACE\_LINK\_LIBRARIES}.

Compile Dependencies are added to CMake's list of dependencies for the current
module, ensuring that they are built before the current module, but they will
not be linked either publicly or privately. They are only used to support the
building of the current module.

The following additional options take no arguments:

\begin{description}
  \item[EXCLUDE\_FROM\_DEFAULT] Exclude this module from collection of modules
    enabled with the \code{ITK\_BUILD\_DEFAULT\_MODULES} CMake option.
  \item[ENABLE\_SHARED]         Build this module as a shared library if the
    \code{BUILD\_SHARED\_LIBS} CMake option is set.
\end{description}

All External and Remote modules should set the \code{EXCLUDE\_FROM\_DEFAULT}
option.


\section{Headers}
\label{sec:Headers}
\index{module!include}

Headers for the module, both \code{*.h} declaration headers and \code{*.hxx}
template definition headers, should be added to the \code{include} directory.
No other explicit CMake configuration is required.

This path will automatically be added to the build include directory paths for
libraries (\ref{sec:Libraries}) and tests (\ref{sec:Tests}) in the module and when
another module declares this module as a dependency.

When a module is installed, headers are installed into a single
directory common to all ITK header files.

When \code{BUILD\_TESTING} is enabled, a header test is automatically
created. This test simply builds a simple executable that \texttt{\#include}s
all header files in the \code{include} directory. This ensures that all
included headers can be found, which tests the module's dependency
specification per Section~\ref{sec:NameAndDependencies}.


\section{Libraries}
\label{sec:Libraries}
\index{module!src}

Libraries generated by a module are created from source files with the
\code{.cxx} extension in a module's \code{src} directory. Some modules are
header-only, and they will not generate any libraries; in this case, the
\code{src} directory is omitted. When present, the \code{src} directory should
contain a \code{CMakeLists.txt} file that describes how to build the library.
A minimal \code{CMakeLists.txt} file is as follows.

\begin{minted}[baselinestretch=1,fontsize=\footnotesize,linenos=false,bgcolor=ltgray]{cmake}
set(AModuleName_SRCS
  itkFooClass.cxx
  itkBarClass.cxx
  )

itk_module_add_library(AModuleName ${AModuleName_SRCS})
\end{minted}

The \code{itk\_module\_add\_library} macro will create a library with the
given sources. The macro will also link the library to the
libraries defined by the module dependency
specification per Section~\ref{sec:NameAndDependencies}. Additionally, the
macro will set CMake target properties associated with the current module to
the given target.

If the \code{ENABLE\_SHARED} option is set on a
module, a shared library will be generated when
the CMake option \code{BUILD\_SHARED\_LIBS} is enabled.  A library symbol
export specification header is also generated for the module.  For a module
with the name \texttt{AModuleName}, the generated header will have the name
\texttt{AModuleNameExport.h}. Include the export header in the module source
headers, and add the export specification macro to the contained classes.  The
macro name in this case would be called \texttt{AModuleName\_EXPORT}. For
example, the file \texttt{itkFooClass.h} would contain

\begin{minted}[baselinestretch=1,fontsize=\footnotesize,linenos=false,bgcolor=ltgray]{cpp}
#include "AModuleNameExport.h"

namespace itk
{

class AModuleName_EXPORT FooClass
{
  ...
\end{minted}

Modules that do not build a library in their \texttt{src} directory or do not
have export specifications on their class declarations should not set
\code{ENABLE\_SHARED}.


\section{Tests}
\label{sec:Tests}
\index{module!test}

Regression tests for a module are placed in the \code{test} directory. This
directory will contain a \texttt{CMakeLists.txt} with the CMake configuration,
test sources, and optional \texttt{Input} and \texttt{Baseline} directories,
which contain test input and baseline image datasets, respectively. Placement
of the input and baseline image datasets within a given module directory is
preferred over placement in the general \texttt{Testing/Data} directory; this
ensures that a module's data is only downloaded when the module is enabled. An
exception to this rule may be widely used input datasets, such as the
\texttt{cthead1.png} image.

An example CMake configuration for a test directory is shown below.

\begin{minted}[baselinestretch=1,fontsize=\footnotesize,linenos=false,bgcolor=ltgray]{cmake}
itk_module_test()

set(ModuleTemplateTests
  itkMinimalStandardRandomVariateGeneratorTest.cxx
  itkLogNormalDistributionImageSourceTest.cxx
  )

CreateTestDriver(ModuleTemplate "${ModuleTemplate-Test_LIBRARIES}" "${ModuleTemplateTests}")

itk_add_test(NAME itkMinimalStandardRandomVariateGeneratorTest
  COMMAND ModuleTemplateTestDriver itkMinimalStandardRandomVariateGeneratorTest
  )

itk_add_test(NAME itkLogNormalDistributionImageSourceTest
  COMMAND ModuleTemplateTestDriver --without-threads
  --compare
    ${ITK_TEST_OUTPUT_DIR}/itkLogNormalDistributionImageSourceTestOutput.mha
    DATA{Baseline/itkLogNormalDistributionImageSourceTestOutput.mha}
  itkLogNormalDistributionImageSourceTest
    ${ITK_TEST_OUTPUT_DIR}/itkLogNormalDistributionImageSourceTestOutput.mha
  )
\end{minted}

The \texttt{CMakeLists.txt} file should start with a call to the
\code{itk\_module\_test} macro. Next, the test sources are listed. The naming
convention for unit test files is \texttt{itk<ClassName>Test.cxx}. Each test
file should be written like a command line executable, but the name of the
\texttt{main} function should be replaced with the name of the test. The
function should accept \code{int argc, char * argv[]} as arguments. To reduce
the time required for linking and to provide baseline comparison functionality,
all tests are linked to into a single test driver executable. To generate the
executable, call the \code{CreateTestDriver} macro.

Tests are defined with the \code{itk\_add\_test} macro. This is a wrapper
around the CMake \code{add\_test} command that will resolve content links in
the \code{DATA} macro. Testing data paths are given inside the \code{DATA}
macro. Content link files, stored in the source code directory, are replaced
by actual content files in the build directory when CMake downloads the
\code{ITKData} target at build time. A content link file has the same name as
its target, but a \texttt{.sha512} extension is added, and the \texttt{.sha512}
file's contents are only the SHA512 hash of its target. Content links for data
files in a Git distributed version control repository prevent repository
bloat. To obtain content links, register an account at
\url{https://data.kitware.com}. Upload images to your account's
\texttt{My folders/Public} folder. Once the image has been uploaded, click on the
item's link, then click the \texttt{Show info} icon. A \texttt{Download key
file} icon will be available to download the content link. Place this file in
the repository tree where referenced by the \code{DATA} macro.

When a test requires a new (or modified) input or baseline image dataset,
the corresponding content link files have to be provided as well. Image
datasets provided should be kept as small as possible. As a rule of thumb,
their size should be under 50~\textit{kB}.

Test commands should call the test driver executable, followed by options for
the test, followed by the test function name, followed by arguments that are
passed to the test. The test driver accepts options like \texttt{--compare}
(or \texttt{--compare-MD5} when using the MD5SUM hash) to compare output images
to baselines or options that modify tolerances on comparisons. An exhaustive
list of options is displayed in \texttt{itkTestDriverInclude.h}.

A few rules must be acknowledged to actually write a units test file
\texttt{itk<ClassName>Test.cxx} for a given ITK class:
\begin{enumerate}
\item All class methods must be exercised.
\item Test cases with values for member variables different from the default
ones should be provided. The usefulness of this rule is especially manifest
for boolean members, whose value usually determines whether a large portion
of code is exercised or not.
\item Test cases to reach the exception cases within the class should be
provided.
\item Regression tests must be included for methods returning a value.
\item When a test detects a failure condition it must return the
\code{EXIT\_FAILURE} value; if a test exits normally, it must return
the \code{EXIT\_SUCCESS} value.
\end{enumerate}

In any case, ITK provides with a number of classes and macros that ease the
process of writing tests and checking the expected results. The following is an
exhaustive list of such tools:
\begin{itemize}
\item \texttt{itkTestingMacros.h}: it contains a number of macros that allow
testing of basic object properties:
\begin{itemize}
\item \code{ITK\_EXERCISE\_BASIC\_OBJECT\_METHODS()}: verifies whether the class and
superclass names provided match the RTTI, and exercises the \code{PrintSelf()}
method. Since the \code{PrintSelf()} method prints all class member variables,
this macro, when exercised, can identify uninitialized member variables.
\item \code{ITK\_TEST\_SET\_GET\_VALUE()}: once a member variable value has been set
using the corresponding Set macro, this macro verifies that the value provided
to the \code{Set()} method was effectively assigned to the member variable
by comparing it to the value returned by the \code{Get()} value.
\item \code{ITK\_TEST\_SET\_GET\_BOOLEAN()}: exercises the \code{Set()/Get()},
and \code{On()/Off()} methods of class applied to a boolean member variable.
\end{itemize}
\item \code{ITK\_TRY\_EXPECT\_NO\_EXCEPTION()}: exercises a method which is expected to
return with no errors. It is only required for methods that are known to throw
exceptions, such as I/O operations, filter updates, etc.
\item \code{ITK\_TRY\_EXPECT\_EXCEPTION()}: exercises a method in the hope of detecting
an exception. This macro allows a test to continue its execution when setting
test cases bound to hit a class' exception cases. It is only required for
methods that are known to throw exceptions, such as I/O operations, filter
updates, etc.
\item \code{itkMath.h}: contains a series of static methods used for basic
type comparison. Methods are available to perform fuzzy floating point equality
comparison, e.g. \code{itk::Math::FloatAlmostEquals()}, to handle expected
cross-platform differences.
\end{itemize}

A test may have some input arguments. When a test does not need any input
argument (e.g., it generates a synthetic input image), the \code{main}
argument names may either be omitted (\code{int itk<ClassName>Test( int,
char* [] )}), or the \code{itkNotUsed }macro can be used (\code{int
itk<ClassName>Test( int itkNotUsed( argc ), char *itkNotUsed( argv ) [] )}),
to avoid compiler warnings about unused variables.

The number of input arguments provided must be checked at the beginning of the
test. If a test requires a fixed number of input arguments, then the argument
number check should verify the exact number of arguments.

It is essential that a test is made quantitative, i.e., the methods' returned
values and the test's output must be compared to a known ground-truth. As
mentioned, ITK contains a series of methods to compare basic types. ITK also
provide a powerful regression tool for a test that checks the validity of a
process over an image, which is the most common case in ITK. To this end, the
test is expected to write its output to a file. The first time the test is run,
the output is expected to be manually placed within the test module's
\texttt{Baseline} folder. Hence, when CTest is executed, the distance between
the test's output and the expected output (i.e., the baseline) is computed. If
the distance is below a configurable tolerance, the regression test is marked as
a success.

\section{Wrapping}
\label{sec:ModuleWrapping}
\index{module!wrapping}

Wrapping for programming languages like Python can be added to a module
through a simple configuration in the module's \code{wrapping} directory.
While wrapping is almost entirely automatic, configuration is necessary
to add two pieces of information,

\begin{enumerate}
  \item The types with which to instantiate templated classes.
  \item Class dependencies which must be wrapped before a given class.
\end{enumerate}

When wrapping a class, dependencies, like the base class and other types used
in the wrapped class's interface, should also be wrapped. The wrapping system
will emit a warning when a base class or other required type is not already
wrapped to ensure proper wrapping coverage. Since module dependencies are
wrapped by the build system before the current module, class wrapping
build order is already correct module-wise. However, it may be required to
wrap classes within a module in a specific order; this order can be specified
in the \code{wrapping/CMakeLists.txt} file.

Many ITK classes are templated, which allows an algorithm to be written once
yet compiled into optimized binary code for numerous pixel types and
spatial dimensions. When wrapping these templated classes, the template
instantiations to wrap must be chosen at build time. The template
that should be used are configured in a module's \code{*.wrap} files.
Wrapping is configured by calling CMake macros defined in the
\code{ITK/Wrapping/TypedefMacros.cmake} file.


\subsection{CMakeLists.txt}

The \code{wrapping/CMakeLists.txt} file calls three macros, and
optionally set a variable, \code{WRAPPER\_SUBMODULE\_ORDER}. The following
example is from the ITKImageFilterBase module:

\begin{minted}[baselinestretch=1,fontsize=\footnotesize,linenos=false,bgcolor=ltgray]{cmake}
itk_wrap_module(ITKImageFilterBase)

set(WRAPPER_SUBMODULE_ORDER
  itkRecursiveSeparableImageFilter
  itkFlatStructuringElement
  itkKernelImageFilter
  itkMovingHistogramImageFilterBase
)
itk_auto_load_submodules()
itk_end_wrap_module()
\end{minted}

The \code{itk\_wrap\_module} macro takes the current module name as an argument. In
some cases, classes defined in the \code{*.wrap} files within a module may depend
each other. The \code{WRAPPER\_SUBMODULE\_ORDER} variable is used to declare
which submodules should be wrapped first and the order they should be
wrapped.


\subsection{Class wrap files}
\label{subsec:ClassWrapFiles}

Wrapping specification for classes is written in the module's \code{*.wrap}
CMake script files. These files call wrapping CMake macros, and they specify
which classes to wrap, whether smart pointer's should be wrapped for the the
class, and which template instantiations to wrap for a class.

Overall toolkit class template instantiations are parameterized by the CMake
build configuration variables shown in Table~\ref{tab:WrappingVariables}.
The wrapping configuration refers to these settings with the shorthand values
listed in the second column.


\begin{table}
\begin{center}
\begin{tabular}{| l | l |}
\hline
\textbf{CMake variable} & \textbf{Wrapping shorthand value} \\
\hline
\hline
\code{ITK\_WRAP\_IMAGE\_DIMS} & List of unsigned integers \\
\hline
\code{ITK\_WRAP\_VECTOR\_COMPONENTS} & List of unsigned integers \\
\hline
\code{ITK\_WRAP\_double} & \code{D} \\
\hline
\code{ITK\_WRAP\_float} & \code{F} \\
\hline
\code{ITK\_WRAP\_complex\_double} & \code{CD} \\
\hline
\code{ITK\_WRAP\_complex\_float} & \code{CF} \\
\hline
\code{ITK\_WRAP\_vector\_double} & \code{VD} \\
\hline
\code{ITK\_WRAP\_vector\_float} & \code{VF} \\
\hline
\code{ITK\_WRAP\_covariate\_vector\_double} & \code{CVD} \\
\hline
\code{ITK\_WRAP\_covariate\_vector\_float} & \code{CVF} \\
\hline
\code{ITK\_WRAP\_signed\_char} & \code{SC} \\
\hline
\code{ITK\_WRAP\_signed\_short} & \code{SS} \\
\hline
\code{ITK\_WRAP\_signed\_long} & \code{SL} \\
\hline
\code{ITK\_WRAP\_unsigned\_char} & \code{UC} \\
\hline
\code{ITK\_WRAP\_unsigned\_short} & \code{US} \\
\hline
\code{ITK\_WRAP\_unsigned\_long} & \code{UL} \\
\hline
\code{ITK\_WRAP\_rgb\_unsigned\_char} & \code{RGBUC} \\
\hline
\code{ITK\_WRAP\_rgb\_unsigned\_short} & \code{RGBUS} \\
\hline
\code{ITK\_WRAP\_rgba\_unsigned\_char} & \code{RGBAUC} \\
\hline
\code{ITK\_WRAP\_rgba\_unsigned\_short} & \code{RGBAUS} \\
\hline
\end{tabular}
\end{center}
\itkcaption[Wrapping Configuration Variables]{CMake wrapping type
  configuration variables and their shorthand value in the wrapping
configuration.}
\label{tab:WrappingVariables}
\end{table}

Class wrap files call sets of wrapping macros for the class to be wrapped. The
macros are often called in loops over the wrapping variables to instatiate the
desired types. The following example demonstates wrapping the
\doxygen{ImportImageFilter} class, taken from the
\code{ITK/Modules/Core/Common/wrapping/itkImportImageFilter.wrap} file.

\begin{minted}[baselinestretch=1,fontsize=\footnotesize,linenos=false,bgcolor=ltgray]{cmake}
itk_wrap_class("itk::ImportImageFilter" POINTER)

  foreach(d ${ITK_WRAP_IMAGE_DIMS})
    foreach(t ${WRAP_ITK_SCALAR})
      itk_wrap_template("${ITKM_${t}}${d}" "${ITKT_${t}},${d}")
    endforeach()
  endforeach()

itk_end_wrap_class()
\end{minted}


\subsubsection{Wrapping Variables}

Instantiations for classes are determined by looping over CMake lists that
collect sets of shorthand wrapping values, namely,

\begin{itemize}
  \item \code{ITK\_WRAP\_IMAGE\_DIMS}
  \item \code{ITK\_WRAP\_IMAGE\_DIMS\_INCREMENTED}
    \\
  \item \code{ITK\_WRAP\_IMAGE\_VECTOR\_COMPONENTS}
  \item \code{ITK\_WRAP\_IMAGE\_VECTOR\_COMPONENTS\_INCREMENTED}
    \\
  \item \code{WRAP\_ITK\_USIGN\_INT}
  \item \code{WRAP\_ITK\_SIGN\_INT}
  \item \code{WRAP\_ITK\_INT}
    \\
  \item \code{WRAP\_ITK\_REAL}
  \item \code{WRAP\_ITK\_COMPLEX\_REAL}
    \\
  \item \code{WRAP\_ITK\_SCALAR}
    \\
  \item \code{WRAP\_ITK\_VECTOR\_REAL}
  \item \code{WRAP\_ITK\_COV\_VECTOR\_REAL}
  \item \code{WRAP\_ITK\_VECTOR}
    \\
  \item \code{WRAP\_ITK\_RGB}
  \item \code{WRAP\_ITK\_RGBA}
  \item \code{WRAP\_ITK\_COLOR}
    \\
  \item \code{WRAP\_ITK\_ALL\_TYPES}
\end{itemize}

Templated classes are wrapped as type aliases for particular instantiations. The
type aliases are named with a name mangling scheme for the template parameter
types. The mangling of common types are stored in CMake variables listed in
Table~\ref{tab:WrappingManglingForPODs},
Table~\ref{tab:WrappingManglingOtherITKPixelTypes}, and
Table~\ref{tab:WrappingManglingITKBasicTypes}. Mangling variables start with the prefix
\code{ITKM\_} and their corresponding C++ type variables start with the
prefix \code{ITKT\_}.

\begin{table}
\begin{center}
\begin{tabular}{| l | l | l |}
\hline
& \textbf{CMake Variable} & \textbf{Value} \\
\hline
\hline
\textbf{Mangling} & ITKM\_B & B \\ \hline
\textbf{C++ Type} & ITKT\_B & bool \\ \hline
\\ \hline
\textbf{Mangling} & ITKM\_UC & UC \\ \hline
\textbf{C++ Type} & ITKT\_UC & unsigned char \\ \hline
\\ \hline
\textbf{Mangling} & ITKM\_US & US \\ \hline
\textbf{C++ Type} & ITKT\_US & unsigned short \\ \hline
\\ \hline
\textbf{Mangling} & ITKM\_UI & UI \\ \hline
\textbf{C++ Type} & ITKT\_UI & unsigned integer \\ \hline
\\ \hline
\textbf{Mangling} & ITKM\_UL & UL \\ \hline
\textbf{C++ Type} & ITKT\_UL & unsigned long \\ \hline
\\ \hline
\textbf{Mangling} & ITKM\_ULL & ULL \\ \hline
\textbf{C++ Type} & ITKT\_ULL & unsigned long long \\ \hline
\\ \hline
\textbf{Mangling} & ITKM\_SC & SC \\ \hline
\textbf{C++ Type} & ITKT\_SC & signed char \\ \hline
\\ \hline
\textbf{Mangling} & ITKM\_SS & SS \\ \hline
\textbf{C++ Type} & ITKT\_SS & signed short \\ \hline
\\ \hline
\textbf{Mangling} & ITKM\_SI & SI \\ \hline
\textbf{C++ Type} & ITKT\_SI & signed integer \\ \hline
\\ \hline
\textbf{Mangling} & ITKM\_SL & SL \\ \hline
\textbf{C++ Type} & ITKT\_SL & signed long \\ \hline
\\ \hline
\textbf{Mangling} & ITKM\_SLL & SLL \\ \hline
\textbf{C++ Type} & ITKT\_SLL & signed long long \\ \hline
\\ \hline
\textbf{Mangling} & ITKM\_F & F \\ \hline
\textbf{C++ Type} & ITKT\_F & float \\ \hline
\\ \hline
\textbf{Mangling} & ITKM\_D & D \\ \hline
\textbf{C++ Type} & ITKT\_D & double \\ \hline
\end{tabular}
\end{center}
\itkcaption[Wrapping CMake Mangling Variables for PODs]{CMake wrapping mangling
  variables, their values, and the corresponding CMake C++ type variables and
their values for plain old datatypes (PODS).}
\label{tab:WrappingManglingForPODs}
\end{table}

\begin{table}
\begin{center}
  \small
  \begin{tabular}{| l | p{0.3\textwidth} | p{0.5\textwidth} |}
\hline
& \textbf{CMake Variable} & \textbf{Value} \\
\hline
\hline
\textbf{Mangling} & ITKM\_C\$\{type\} & C\$\{type\} \\ \hline
\textbf{C++ Type} & ITKT\_C\$\{type\} & std::complex\textless \$\{type\} \textgreater\\ \hline
\\ \hline
\textbf{Mangling} & ITKM\_A\$\{type\} & A\$\{type\} \\ \hline
\textbf{C++ Type} & ITKT\_A\$\{type\} & itk::Array\textless \$\{type\} \textgreater\\ \hline
\\ \hline
\textbf{Mangling} & ITKM\_FA\$\{ITKM\_\$\{type\}\}\$\{dim\} & FA\$\{ITKM\_\$\{type\}\}\$\{dim\} \\ \hline
\textbf{C++ Type} & ITKT\_FA\$\{ITKM\_\$\{type\}\}\$\{dim\} & itk::FixedArray\textless \$\{ITKT\_\$\{type\}\}, \$\{dim\} \textgreater \\ \hline
\\ \hline
\textbf{Mangling} & ITKM\_RGB\$\{dim\} & RGB\$\{dim\} \\ \hline
\textbf{C++ Type} & ITKT\_RGB\$\{dim\} & itk::RGBPixel\textless \$\{dim\} \textgreater\\ \hline
\\ \hline
\textbf{Mangling} & ITKM\_RGBA\$\{dim\} & RGBA\$\{dim\} \\ \hline
\textbf{C++ Type} & ITKT\_RGBA\$\{dim\} & itk::RGBAPixel\textless \$\{dim\} \textgreater\\ \hline
\\ \hline
\textbf{Mangling} & ITKM\_V\$\{ITKM\_\$\{type\}\}\$\{dim\} & V\$\{ITKM\_\$\{type\}\}\$\{dim\} \\ \hline
\textbf{C++ Type} & ITKT\_V\$\{ITKM\_\$\{type\}\}\$\{dim\} & itk::Vector\textless \$\{ITKT\_\$\{type\}\}, \$\{dim\} \textgreater \\ \hline
\\ \hline
\textbf{Mangling} & ITKM\_CV\$\{ITKM\_\$\{type\}\}\$\{dim\} & CV\$\{ITKM\_\$\{type\}\}\$\{dim\} \\ \hline
\textbf{C++ Type} & ITKT\_CV\$\{ITKM\_\$\{type\}\}\$\{dim\} & itk::CovariantVector\textless \$\{ITKT\_\$\{type\}\}, \$\{dim\} \textgreater \\ \hline
\\ \hline
\textbf{Mangling} & ITKM\_VLV\$\{ITKM\_\$\{type\}\}\$\{dim\} & VLV\$\{ITKM\_\$\{type\}\}\$\{dim\} \\ \hline
\textbf{C++ Type} & ITKT\_VLV\$\{ITKM\_\$\{type\}\}\$\{dim\} & itk::VariableLengthVector\textless \$\{ITKT\_\$\{type\}\}, \$\{dim\} \textgreater \\ \hline
\\ \hline
\textbf{Mangling} & ITKM\_SSRT\$\{ITKM\_\$\{type\}\}\$\{dim\} & SSRT\$\{ITKM\_\$\{type\}\}\$\{dim\} \\ \hline
\textbf{C++ Type} & ITKT\_SSRT\$\{ITKM\_\$\{type\}\}\$\{dim\} & itk::SymmetricSecondRankTensor\textless \$\{ITKT\_\$\{type\}\}, \$\{dim\} \textgreater \\ \hline
\end{tabular}
\end{center}
\itkcaption[Wrapping CMake Mangling Variables for other ITK pixel types.]{CMake wrapping mangling
  variables, their values, and the corresponding CMake C++ type variables and
  their values for other ITK pixel types.}
\label{tab:WrappingManglingOtherITKPixelTypes}
\end{table}


\begin{table}
\begin{center}
  \small
  \begin{tabular}{| l | p{0.3\textwidth} | p{0.5\textwidth} |}
\hline
& \textbf{CMake Variable} & \textbf{Value} \\
\hline
\hline
\textbf{Mangling} & ITKM\_O\$\{dim\} & O\$\{dim\} \\ \hline
\textbf{C++ Type} & ITKT\_O\$\{dim\} & itk::Offset\textless \$\{dim\} \textgreater\\ \hline
\\ \hline
\textbf{Mangling} & ITKM\_CI\$\{ITKM\_\$\{type\}\}\$\{dim\} & CI\$\{ITKM\_\$\{type\}\}\$\{dim\} \\ \hline
\textbf{C++ Type} & ITKT\_CI\$\{ITKM\_\$\{type\}\}\$\{dim\} & itk::ContinuousIndex\textless \$\{ITKT\_\$\{type\}\}, \$\{dim\} \textgreater \\ \hline
\\ \hline
\textbf{Mangling} & ITKM\_P\$\{ITKM\_\$\{type\}\}\$\{dim\} & P\$\{ITKM\_\$\{type\}\}\$\{dim\} \\ \hline
\textbf{C++ Type} & ITKT\_P\$\{ITKM\_\$\{type\}\}\$\{dim\} & itk::Point\textless \$\{ITKT\_\$\{type\}\}, \$\{dim\} \textgreater \\ \hline
\\ \hline
\textbf{Mangling} & ITKM\_I\$\{ITKM\_\$\{type\}\}\$\{dim\} & I\$\{ITKM\_\$\{type\}\}\$\{dim\} \\ \hline
\textbf{C++ Type} & ITKT\_I\$\{ITKM\_\$\{type\}\}\$\{dim\} & itk::Image\textless \$\{ITKT\_\$\{type\}\}, \$\{dim\} \textgreater \\ \hline
\\ \hline
\textbf{Mangling} & ITKM\_VI\$\{ITKM\_\$\{type\}\}\$\{dim\} & VI\$\{ITKM\_\$\{type\}\}\$\{dim\} \\ \hline
\textbf{C++ Type} & ITKT\_VI\$\{ITKM\_\$\{type\}\}\$\{dim\} & itk::VectorImage\textless \$\{ITKT\_\$\{type\}\}, \$\{dim\} \textgreater \\ \hline
\\ \hline
\textbf{Mangling} & ITKM\_SO\$\{dim\} & SO\$\{dim\} \\ \hline
\textbf{C++ Type} & ITKT\_SO\$\{dim\} & itk::SpatialObject\textless \$\{dim\} \textgreater\\ \hline
\\ \hline
\textbf{Mangling} & ITKM\_SE\$\{dim\} & SE\$\{dim\} \\ \hline
\textbf{C++ Type} & ITKT\_SE\$\{dim\} & itk::FlatStructuringElement\textless \$\{dim\} \textgreater\\ \hline
\\ \hline
\textbf{Mangling} & ITKM\_H\$\{ITKM\_\$\{type\}\} & H\$\{ITKM\_\$\{type\}\} \\ \hline
\textbf{C++ Type} & ITKT\_H\$\{ITKM\_\$\{type\}\} & itk::Statistics::Histogram\textless \$\{ITKT\$\{type\}\} \textgreater\\ \hline
\\ \hline
\textbf{Mangling} & ITKM\_ST & Depends on platform \\ \hline
\textbf{C++ Type} & ITKT\_ST & itk::SizeValueType \\ \hline
\\ \hline
\textbf{Mangling} & ITKM\_IT & Depends on platform \\ \hline
\textbf{C++ Type} & ITKM\_IT & itk::IdentifierType \\ \hline
\\ \hline
\textbf{Mangling} & ITKM\_OT & Depends on platform\\ \hline
\textbf{C++ Type} & ITKT\_OT & itk::OffsetValueType \\ \hline
\end{tabular}
\end{center}
\itkcaption[Wrapping CMake Mangling Variables for Basic ITK types.]{CMake wrapping mangling
  variables, their values, and the corresponding CMake C++ type variables and
  their values for basic ITK types.}
\label{tab:WrappingManglingITKBasicTypes}
\end{table}

\normalsize


\subsubsection{Wrapping Enumerations}

Enumeration classes need to be wrapped through the class they are declared in
using the \code{itk\_wrap\_simple\_class}, e.g.:
\small
\begin{minted}[baselinestretch=1,fontsize=\footnotesize,linenos=false,bgcolor=ltgray]{cmake}
itk_wrap_simple_class("itk::MathematicalMorphologyEnums")
\end{minted}
\normalsize

which results in access to the class in Python as
\code{itk.MathematicalMorphologyEnum}, its \code{Algorithm} enumeration class
being accesible as \code{itk.MathematicalMorphologyEnums.Algorithm}, and its
enum-list being accessed as
\code{itk.MathematicalMorphologyEnums.Algorithm\_BASIC},
\code{itk.MathematicalMorphologyEnums.Algorithm\_HISTO}, etc.


\subsubsection{Wrapping Macros}

There are a number of a wrapping macros called in the \code{wrapping/*.wrap}
files. Macros are specialized for classes that use \doxygen{SmartPointer}s
and templated classes.

For non-templated classes, the \textbf{itk\_wrap\_simple\_class} is used. This
macro takes fully qualified name of the class as an argument. Lastly, the
macro takes an optional argument that can have the values \code{POINTER},
\code{POINTER\_WITH\_CONST\_POINTER}, or \code{POINTER\_WITH\_SUPERCLASS}. If
this argument is passed, then the type alias \code{classname::Pointer},
\code{classname::Pointer} and \code{classname::ConstPointer}, or
\code{classname::Pointer} and \code{classname::Superclass::Pointer} are
wrapped. Thus, the wrapping configuration for \doxygen{Object} is

\begin{minted}[baselinestretch=1,fontsize=\footnotesize,linenos=false,bgcolor=ltgray]{cmake}
itk_wrap_simple_class("itk::Object" POINTER)
\end{minted}

When wrapping templated classes, three or more macro calls are required.
First, \textbf{itk\_wrap\_class} is called.  Again, its arguments are the
fully qualified followed by an option argument that can have the value
\code{POINTER}, \code{POINTER\_WITH\_CONST\_POINTER},
\code{POINTER\_WITH\_SUPERCLASS}, \code{POINTER\_WITH\_2\_SUPERCLASSES},
\code{EXPLICIT\_SPECIALIZATION},
\code{POINTER\_WITH\_EXPLICIT\_SPECIALIZATION}, \code{ENUM}, or
\code{AUTOPOINTER}. Next, a series of calls are made to macros that declare
which templates to instantiate. Finally, the \textbf{itk\_end\_wrap\_class}
macro is called, which has no arguments.

The most general template wrapping macro is \textbf{itk\_wrap\_template}. Two
arguments are required. The first argument is a mangled suffix to be added to
the class name, which uniquely identifies the instantiation. This argument is usually
specified at least partially with \code{ITKM\_} mangling
variables. The second argument is the is template instantiation in C++ form.
This argument is usually specified at least partially with \code{ITKT\_}
C++ type variables. For example, wrapping for
\doxygen{ImageSpatialObject}, which templated a dimension and pixel type, is
configured as

\begin{minted}[baselinestretch=1,fontsize=\footnotesize,linenos=false,bgcolor=ltgray]{cmake}
itk_wrap_class("itk::ImageSpatialObject" POINTER)
  # unsigned char required for the ImageMaskSpatialObject
  UNIQUE(types "UC;${WRAP_ITK_SCALAR}")

  foreach(d ${ITK_WRAP_IMAGE_DIMS})
    foreach(t ${types})
      itk_wrap_template("${d}${ITKM_${t}}" "${d},${ITKT_${t}}")
    endforeach()
  endforeach()
itk_end_wrap_class()
\end{minted}


In addition to \code{itk\_wrap\_template}, there are template wrapping macros
specialized for wrapping image filters. The highest level macro is
\textbf{itk\_wrap\_image\_filter}, which is used for wrapping image filters
that need one or more image parameters of the same type. This macro has two
required arguments. The first argument is a semicolon delimited CMake list of
pixel types. The second argument is the number of image template arguments for
the filter. An optional third argument is a dimensionality condition to
restrict the dimensions that the filter can be instantiated. The
dimensionality condition can be a number indicating the dimension
allowed, a semicolon delimited CMake list of dimensions, or a string of the
form \code{n+}, where \code{n} is a number, to indicate that instantiations
are allowed for dimension \code{n} and above. The wrapping specification for
\doxygen{ThresholdMaximumConnectedComponentsImageFilter} is

\begin{minted}[baselinestretch=1,fontsize=\footnotesize,linenos=false,bgcolor=ltgray]{cmake}
itk_wrap_class("itk::ThresholdMaximumConnectedComponentsImageFilter" POINTER)
  itk_wrap_image_filter("${WRAP_ITK_INT}" 1 2+)
itk_end_wrap_class()
\end{minted}

If it is desirable or required to instantiate an image filter with different
image types, the \textbf{itk\_wrap\_image\_filter\_combinations} macro is
applicable. This macro takes a variable number of parameters, where each
parameter is a list of the possible image pixel types for the corresponding
filter
template parameters. A condition to restrict dimensionality may again be
optionally passed as the last argument. For example, wrapping for
\doxygen{VectorMagnitudeImageFilter} is specified with

\begin{minted}[baselinestretch=1,fontsize=\footnotesize,linenos=false,bgcolor=ltgray]{cmake}
itk_wrap_class("itk::VectorMagnitudeImageFilter" POINTER_WITH_SUPERCLASS)
  itk_wrap_image_filter_combinations("${WRAP_ITK_COV_VECTOR_REAL}" "${WRAP_ITK_SCALAR}")
itk_end_wrap_class()
\end{minted}

The final template wrapping macro is \textbf{itk\_wrap\_image\_filter\_types}.
This macro takes a variable number of arguments that should correspond to the
image pixel types in the filter's template parameter list. Again, an optional
dimensionality condition can be specified as the last argument. For example,
wrapping for \doxygen{RGBToLuminanceImageFilter} is specified with

\begin{minted}[baselinestretch=1,fontsize=\footnotesize,linenos=false,bgcolor=ltgray]{cmake}
itk_wrap_class("itk::RGBToLuminanceImageFilter" POINTER_WITH_SUPERCLASS)
  if(ITK_WRAP_rgb_unsigned_char AND ITK_WRAP_unsigned_char)
    itk_wrap_image_filter_types(RGBUC UC)
  endif(ITK_WRAP_rgb_unsigned_char AND ITK_WRAP_unsigned_char)

  if(ITK_WRAP_rgb_unsigned_short AND ITK_WRAP_unsigned_short)
    itk_wrap_image_filter_types(RGBUS US)
  endif(ITK_WRAP_rgb_unsigned_short AND ITK_WRAP_unsigned_short)

  if(ITK_WRAP_rgba_unsigned_char AND ITK_WRAP_unsigned_char)
    itk_wrap_image_filter_types(RGBAUC UC)
  endif(ITK_WRAP_rgba_unsigned_char AND ITK_WRAP_unsigned_char)

  if(ITK_WRAP_rgba_unsigned_short AND ITK_WRAP_unsigned_short)
    itk_wrap_image_filter_types(RGBAUS US)
  endif(ITK_WRAP_rgba_unsigned_short AND ITK_WRAP_unsigned_short)
itk_end_wrap_class()
\end{minted}

In some cases, it necessary to specify the headers required to build wrapping
sources for a class. To specify additional headers to included in the generated
wrapping C++ source, use the \textbf{itk\_wrap\_include} macro. This macro takes the
name of the header to include, and it can be called multiple times.

By default, the class wrapping macros include a header whose filename
corresponds to the name of the class to be wrapped according to ITK naming
conventions. To override the default behavior, set the CMake variable
\code{WRAPPER\_AUTO\_INCLUDE\_HEADERS} to \code{OFF} before calling
\code{itk\_wrap\_class}. For example,

\begin{minted}[baselinestretch=1,fontsize=\footnotesize,linenos=false,bgcolor=ltgray]{cmake}
set(WRAPPER_AUTO_INCLUDE_HEADERS OFF)
itk_wrap_include("itkTransformFileReader.h")
itk_wrap_class("itk::TransformFileReaderTemplate" POINTER)
  foreach(t ${WRAP_ITK_REAL})
    itk_wrap_template("${ITKM_${t}}" "${ITKT_${t}}")
  endforeach()
itk_end_wrap_class()
\end{minted}

There are a number of convenience CMake macros available to manipulate lists
of template parameters. These macros take the variable name to populate with
their output as the first argument followed by input arguments. The
\textbf{itk\_wrap\_filter\_dims} macro will process the dimensionality
condition previously described for the filter template wrapping macros.
\textbf{DECREMENT}, \textbf{INCREMENT} are macros that operate on dimensions.
The \textbf{INTERSECTION} macro finds the intersection of two list arguments.
Finally, the \textbf{UNIQUE} macro removes duplicates from the given list.


\subsubsection{Wrapping Tests}

Wrapped classes need to be accompanied with their own test files to ensure that
the classes can be instantiated correctly. Similar to regular C++ tests, the
tests for wrapped classes dwell in a \code{CMakeLists.txt} file inside the
\code{wrapping/test} directory of the module of interest, e.g.
\code{Modules/<ModuleName>/<SubModuleName>/wrapping/test/CMakeLists.txt}. The
following is an example of how such file would look like for the wrapping
corresponding to the \doxygen{ExtrapolateImageFunction} and
\doxygen{WindowedSincInterpolateImageFunction} classes:

\begin{minted}[baselinestretch=1,fontsize=\footnotesize,linenos=false,bgcolor=ltgray]{cmake}
itk_python_expression_add_test(NAME itkExtrapolateImageFunctionPythonTest
  EXPRESSION "instance = itk.ExtrapolateImageFunction.New()")
itk_python_expression_add_test(NAME itkWindowedSincInterpolateImageFunctionPythonTest
  EXPRESSION "instance = itk.WindowedSincInterpolateImageFunction.New()")
\end{minted}


\subsection{Debugging Strategies}
\label{subsec:DebuggingStrategies}

ITK wrappings allow users to make use of ITK classes in other languages for various
purposes, such as relying on ITK Python wrappings to sidestep C++ compilation steps
for rapid prototyping. However, this often introduces additional complexity in the
process of identifying and localizing issues in C++ classes or even in the wrapping
process itself. Fortunately, language-specific tools are available to assist in
the debugging process. In this section we focus on strategies for investigating
ITK Python code generated with SWIG.

\subsubsection{Swig Python Architecture}
\label{subsubsec:SwigArchitecture}

ITK 5.x uses SWIG (Simplified Wrapper and Interface Generator) to distill ITK C++
classes into Python modules. This largely takes place in four distinct stages:

\begin{itemize}

\item \code{.wrap} CMake files, included in the ITK source tree in the \code{Wrapping}
folder for each module to define class template instantiations to be wrapped.
These are discussed in Section~\ref{subsec:ClassWrapFiles}.

\item SWIG \code{.cpp} source files generated at compile time at \code{Wrapping/Modules}
under the ITK build tree. These C++ files explicitly implement the class and template
instantiations defined in the class \code{.wrap} files in the source tree.
Debug symbols will be generated for these files.

\item SWIG compiled code. For Python wrappings these are generated as Python
\code{.pyd} (Windows) or \code{.so} (Linux or macOS) binaries and Python \code{.py} modules at
\code{Wrapping/Generators/Python/itk} in the ITK build tree.

\item Additional Python configuration files are generated in the
\code{Wrapping/Generators/Python} directory and its subdirectories.
\code{WrapITK.pth} provides the path for a Python environment to find the ITK
module, while \code{\_\_init\_\_.py} allows the module under development to be loaded correctly at
runtime. \code{<module\_name>Config.py} defines module dependencies and class
template definitions, while \code{<module\_name>\_snake\_case.py} maps
C++-style filter pipeline executions to Pythonic snake case functions.

\end{itemize}

ITK Python pre-compiled wheels may be obtained from the PyPI package index and contain
pre-compiled binaries without debugging symbols. To debug the native binaries a local build
must be created as in Section~\ref{sec:UsingCMakeForConfiguringAndBuildingITK} with a
\code{Debug} or \code{RelWithDebInfo} CMake build configuration as described below.

\begin{minted}[baselinestretch=1,fontsize=\footnotesize,linenos=false,bgcolor=ltgray]{bash}
python -m pip install itk
\end{minted}


\subsubsection{Python Runtime Tracing}
\label{subsubsec:PythonRuntimeTracing}

ITK Python contains glue behavior to make ITK classes behave in a Pythonic manner,
such as querying object attributes, joining class names to template instantiations, and more.
Python-specific behavior in ITK Python may be investigated with the
Python Debugger module, \code{pdb}.

Tracing can be performed on a function call with \code{pdb.run}, or by editing ITK Python
files to add a \code{pdb.set\_trace()} statement inline. In the following code snippet
an image is loaded and the debugger is set up to trace through an image cast operation.

\begin{minted}[baselinestretch=1,fontsize=\footnotesize,linenos=false,bgcolor=ltgray]{bash}
(venv-itk) > python
>>> import itk
>>> import pdb
>>> image = itk.imread(r'myimage.mha',pixel_type=itk.F)
>>> pdb.runeval('itk.cast_image_filter(image,ttype=[type(image),itk.Image[itk.UC,2]])')
> <string>(1)<module>()
(Pdb)
\end{minted}

At this point the debugger can step into and through Python code for translating ITK
type names and getting the correct template instantiations to run the cast operation. More
information on Python debugger commands can be found at
\href{https://docs.python.org/3/library/pdb.html}{https://docs.python.org/3/library/pdb.html}.

While the Python debugger is useful, it does not allow us to examine implementation
details of ITK classes in the native binary. A deeper investigation may be necessary for localizing
errors in ITK classes.


\subsubsection{C++ Runtime Tracing}
\label{subsubsec:CppRuntimeTracing}

As discussed in Section~\ref{subsubsec:SwigArchitecture}, SWIG wrapping generates
C++ source files and manages the interface and ownership semantics between
Python objects and C++ objects during ITK compilation.
When binary debug symbols are available, a running Python process may be attached to step through
ITK or ITK SWIG sources at runtime. Several steps are required to set up and execute debugging:

\begin{enumerate}

\item The ITK build must be configured so that debug symbols
are generated. Python wrapping must also be enabled.
This is accomplished by setting the CMake variables

\code{CMAKE\_BUILD\_TYPE:STRING="RelWithDebInfo"} and \code{ITK\_WRAP\_PYTHON:BOOL="On"}.
Note that the "RelWithDebInfo" build type is strongly encouraged over a "Debug"
build as the former will build against a standard Python distribution.
See Section~\ref{sec:UsingCMakeForConfiguringAndBuildingITK} for a detailed
explanation of how to build ITK locally with CMake.

\item A Python virtual environment must be appropriately configured with
\code{WrapITK.pth} so that the ITK debug build can be \code{import}ed.
See Section~\ref{sec:Wrapping} for further explanation.

\item The ITK modules to be debugged must be loaded in a new Python session initialized
from the given virtual environment. Given that ITK Python uses lazy loading, it is
pragmatic to use \code{itk.force\_load()} to ensure that all possible debug symbols
are made available. The \code{os} module can be used to identify the PID of the given session.

\begin{minted}[baselinestretch=1,fontsize=\footnotesize,linenos=false,bgcolor=ltgray]{bash}
(venv-itk) > python
>>> import itk
>>> itk.force_load()
>>> import os
>>> os.getpid()
99999
\end{minted}

\item The Python session may be attached to a debugger using the returned PID.

\begin{itemize}

\item On a Windows operating system, Microsoft Visual Studio 2019 or a similar platform
can be used for attaching to a running process for debugging. Select "Attach To Process"
from the Debug menu, choose "Native" code, and then search for the process PID. If
debug symbols were generated correctly then ITK modules will appear under the list of
loaded modules.

In Visual Studio, debugging can be enabled right from the start if the Python script
is loaded into Visual Studio as part of a "Python Project".
Mixed mode debugging needs to be enabled, as per Visual Studio
documentation\footnote{
\url{https://docs.microsoft.com/en-us/visualstudio/python/debugging-mixed-mode-c-cpp-python-in-visual-studio}}.
Starting a project like this is an order of magnitude slower, as many debug symbols need to be loaded and examined.

\item On a Linux operating system the GNU Project Debugger \code{gdb} can be used
for attaching to a running Python process, reading symbol files, and setting breakpoints.
The following example attaches to a running process and sets a breakpoint inside
an \code{itk.Image} Python object. It may be necessary to elevate user permissions
to allow \code{gdb} to attach to the running process.

\begin{minted}[baselinestretch=1,fontsize=\footnotesize,linenos=false,bgcolor=ltgray]{bash}
(venv-itk) > gdb
(gdb) > attach 99999
Reading symbols from
  /path/to/ITK-build/Wrapping/Generators/Python/itk/_ITKPyBasePython.so...
Reading symbols from
  /path/to/ITK-build/Wrapping/Generators/Python/itk/_ITKCommonPython.so...
(gdb) > break /path/to/ITK-build/Wrapping/Modules/ITKCommon/itkImagePython.cpp:<ln>
Breakpoint 1 at ...:
file /path/to/ITK-build/Wrapping/Modules/ITKCommon/itkImagePython.cpp, line <ln>.
(gdb) > break /path/to/ITK-source/Core/Common/include/itkImage.hxx:<ln>
Breakpoint 2 at ...:
/path/to/ITK-source/Modules/Core/Common/include/itkImage.hxx:<ln>
(gdb) > c

... continue in Python session until breakpoint is hit ...
\end{minted}

\item On a macOS operating system the LLDB debugger can be used for attaching to a
Python process in much the same way as GDB on Linux, with a few extra security
requirements and slightly different command syntax. The following example
attaches to a running process and sets a breakpoint inside an \code{itk.Image}
Python object.

\begin{minted}[baselinestretch=1,fontsize=\footnotesize,linenos=false,bgcolor=ltgray]{bash}
(venv-itk) > lldb
(lldb) process attach -- pid 99999
Process 99999 stopped
* thread #1, queue = 'com.apple.main-thread', stop reason = signal SIGSTOP
    frame #0: 0x00007fff203ec656 libsystem_kernel.dylib`__select + 10
libsystem_kernel.dylib`__select:
->  0x7fff203ec656 <+10>: jae    0x7fff203ec660            ; <+20>
    0x7fff203ec658 <+12>: movq   %rax, %rdi
    0x7fff203ec65b <+15>: jmp    0x7fff203e56bd            ; cerror
    0x7fff203ec660 <+20>: retq
Target 0: (Python) stopped.

Executable module set to
  "/Library/Frameworks/Python.framework/Versions/3.9/
    Resources/Python.app/Contents/MacOS/Python".
Architecture set to: x86_64h-apple-macosx-.

(lldb) breakpoint set
  -f /path/to/ITK/Modules/Core/Common/include/itkImage.hxx
  --line <ln>
Breakpoint 1: 172 locations.
(lldb) continue

... continue in Python session until breakpoint is hit ...
\end{minted}

LLDB command syntax is documented at \url{https://lldb.llvm.org/index.html}.

Developers may find it necessary to examine the follow security concepts
and requirements in order to permit \code{lldb} to attach to Python:

\begin{itemize}

\item The Python process must be authorized for debugging. MacOS relies on the
process of "hardened" runtimes to mitigate security concerns, which reduces
the ability of debuggers such as \code{lldb} and other processes to attach
to and intercept the functions of other programs. Python distributions
are intentionally "hardened" in this way, but additional settings can be
enabled to allow just-in-time debugging.

\item It may be necessary to enter developer mode to allow Python debugging.
This is accomplished with the following command in the developer console:

\begin{minted}[baselinestretch=1,fontsize=\footnotesize,linenos=false,bgcolor=ltgray]{bash}
DevToolsSecurity -enable
\end{minted}

\item It may be necessary to add entitlements to the Python executable so that
\code{lldb} can attach to the hardened process. This may be accomplished by
updating a \code{.plist} entitlements file and setting the executable entitlements.

\begin{minted}[baselinestretch=1,fontsize=\footnotesize,linenos=false,bgcolor=ltgray]{bash}
codesign -d --entitlements :-
  "/path/to/python" >> "/tmp/path/to/python_entitlements.plist"
/usr/libexec/PlistBuddy -c
  "Add :com.apple.security.get-task-allow bool true"
  "/tmp/path/to/python_entitlements.plist"
/usr/libexec/PlistBuddy -c
  "Add :com.apple.security.cs.allow-jit bool true"
  "/tmp/path/to/python_entitlements.plist"
codesign --force --options runtime --sign -
  --entitlements "/tmp/path/to/python_entitlements.plist"
  "/path/to/python"
\end{minted}

\item If attaching to the process continues to fail, log files can
be dumped with \code{log collect} and opened in the Console application.
\code{lldb} error messages will be listed as \code{debugserver} entries.

\end{itemize}

\end{itemize}

\end{enumerate}

With these steps completed the respective debugger can be used to set breakpoints
and step through C++ source code for a respective ITK Python execution.

The debugger can also be used for examining runtime failures and crashes
either at the time the error occurs or posthumously with a dump file.

\begin{itemize}

\item On Windows, Microsoft Visual Studio will catch process aborts
to allow the attached process to be examined before exit. Stacks, threads,
and variables are made available to the user for backtracing via the
\code{Debug} toolbar menu. Dump files in the minidump format may also
be manually saved and reloaded later for investigation\footnote{
\url{https://docs.microsoft.com/en-us/visualstudio/debugger/using-dump-files?view=vs-2022}}.

\item On Linux, \code{gdb} will catch process aborts at runtime to allow
a developer to examine the program state before it exits.
If allowed, core dumps can also be generated on program failures
to allow posthumous debugging. The following sample
configures a Linux system to remove the default limit of 0 for allowable
coredump size and to write out coredump files to the \code{/tmp/} directory.

\begin{minted}[baselinestretch=1,fontsize=\footnotesize,linenos=false,bgcolor=ltgray]{bash}
> ulimit -c unlimited
> sudo bash -c 'echo "/tmp/coredump-%e.%p" > /proc/sys/kernel/core_pattern'
\end{minted}

More information is available in Python documentation\footnote{
\url{https://pythondev.readthedocs.io/debug_tools.html\#create-a-core-dump-file}}.

\item On MacOS, \code{lldb} will catch process aborts at runtime
and may also be used to examine core dumps. The following sample
configures a MacOS system to write out core dump files to the \code{/cores/}
directory and then runs \code{lldb} to inspect a core dump.

\begin{minted}[baselinestretch=1,fontsize=\footnotesize,linenos=false,bgcolor=ltgray]{bash}
(venv-itk) > ulimit -c unlimited

... Run process and generate a core dump ...

(venv-itk) > lldb
(lldb) target create "python3" --core "/cores/core.1007"
Core file '/cores/core.1007' (x86_64) was loaded.
\end{minted}

\end{itemize}


\section{Third-Party Dependencies}
\label{sec:ThirdParty}
\index{module!third-party}

When an ITK module depends on another ITK module, it simply lists its
dependencies as described in Section \ref{sec:NameAndDependencies}. A module
can also depend on non-ITK third-party libraries. This third-party library can
be encapsulated in an ITK module -- see examples in the
\code{ITK/Modules/ThirdParty} directory. Or, the dependency can be built or
installed on the system and found with CMake. This section describes how to
add the CMake configuration to a module for it to find and use a third-party
library dependency.


\subsection{itk-module-init.cmake}

The \code{itk-module-init.cmake} file, if present, is found in the top level
directory of the module next to the \code{itk-module.cmake} file. This file
informs CMake of the build configuration and location of the third-party
dependency. To inform CMake about the OpenCV library, use the
\code{find\_package} command,

\begin{minted}[baselinestretch=1,fontsize=\footnotesize,linenos=false,bgcolor=ltgray]{cmake}
find_package(OpenCV REQUIRED)
\end{minted}


\subsection{CMakeList.txt}

A few additions are required to the top level \code{CMakeLists.txt} of the
module.

First, the \code{itk-module-init.cmake} file should be explicitly included
when building the module externally against an existing ITK build tree.

\begin{minted}[baselinestretch=1,fontsize=\footnotesize,linenos=false,bgcolor=ltgray]{cmake}
if(NOT ITK_SOURCE_DIR)
  include(itk-module-init.cmake)
endif()
project(ITKVideoBridgeOpenCV)
\end{minted}

Optionally, the dependency libraries are added to the
\code{<module-name>\_LIBRARIES} variable. Alternatively, if the module creates
a library, publically link to the dependency libraries. Our
ITKVideoBridgeOpenCV module example creates its own library, named
\code{ITKVideoBridgeOpenCV}, and publically links to the OpenCV libraries.

\code{CMakeLists.txt}:
\begin{minted}[baselinestretch=1,fontsize=\footnotesize,linenos=false,bgcolor=ltgray]{cmake}
set(ITKVideoBridgeOpenCV_LIBRARIES ITKVideoBridgeOpenCV)
\end{minted}

\code{src/CMakeLists.txt}:
\begin{minted}[baselinestretch=1,fontsize=\footnotesize,linenos=false,bgcolor=ltgray]{cmake}
target_link_libraries(ITKVideoBridgeOpenCV LINK_PUBLIC ${OpenCV_LIBS})
\end{minted}

Next, CMake export code is created. This code is loaded by CMake when another
project uses this module. The export code stores where the dependency was
located when the module was built, and how CMake should find it. Two versions
are required for the build tree and for the install tree.

\begin{minted}[baselinestretch=1,fontsize=\footnotesize,linenos=false,bgcolor=ltgray]{cmake}
# When this module is loaded by an app, load OpenCV too.
set(ITKVideoBridgeOpenCV_EXPORT_CODE_INSTALL "
set(OpenCV_DIR \"${OpenCV_DIR}\")
find_package(OpenCV REQUIRED)
")
set(ITKVideoBridgeOpenCV_EXPORT_CODE_BUILD "
if(NOT ITK_BINARY_DIR)
  set(OpenCV_DIR \"${OpenCV_DIR}\")
  find_package(OpenCV REQUIRED)
endif()
")
\end{minted}

Finally, set the \code{<module-name>\_SYSTEM\_INCLUDE\_DIRS} and
\code{<module-name>\_SYSTEM\_LIBRARY\_DIRS}, if required, to append
compilation header directories and library linking directories for this
module.

\begin{minted}[baselinestretch=1,fontsize=\footnotesize,linenos=false,bgcolor=ltgray]{cmake}
set(ITKVideoBridgeOpenCV_SYSTEM_INCLUDE_DIRS ${OpenCV_INCLUDE_DIRS})
set(ITKVideoBridgeOpenCV_SYSTEM_LIBRARY_DIRS ${OpenCV_LIB_DIR})
\end{minted}

\section{Contributing with a Remote Module}
\label{sec:ContributingRemoteModules}

For most ITK community members, the modularization of the toolkit is relatively
transparent. The default configuration includes all the (default) modules into
the ITK library, which is used to build their own ITK applications.

For ITK developers and code contributors, the modular structure imposes rules
for organizing the source code, building the library and contributing to the
ITK source code repository.

A Module may be developed outside the main ITK repository, but it may be
made available in the ITK repository as a Remote Module. The Remote Module
infrastructure enables fast dissemination of research code through ITK without
increasing the size of the main repository. The Insight Journal
(\url{https://www.insight-journal.org/}) adds support for ITK module submissions
with automatic dashboard testing (see Section~\ref{sec:CDash} on
page~\pageref{sec:CDash} for further details).

The source code of a Remote Module can be downloaded by CMake (with a CMake
variable switch) at ITK CMake configuration time, making it a convenient way to
distribute modular source code.

\subsection{Policy for Adding and Removing Remote Modules}
\label{subsec:RemoteModuleAddRemovePolicy}

A module can be added to the list of remotes if it satisfies the following
criteria:
\begin{itemize}
\item There is a peer-reviewed article in an online, open access journal (such
as the Insight Journal) describing the theory behind and usage of the module.
\item There is a nightly build against ITK master on the CDash dashboard that
builds and passes tests successfully.
\item A name and contact email exists for the dashboard build. The maintainer
of the dashboard build does not necessarily need to be the original author of
the Insight Journal article.
\item The license should be compatible with the rest of the toolkit. That is
it should be an Open Source Initiative-approved
license\footnote{\url{https://opensource.org/licenses}} without copyleft or
non-commercial restrictions. Ideally, it should be an Apache 2.0 license
assigned to NumFOCUS as found in the rest of the toolkit. Note that the module
should contain neither patented code, nor algorithms, nor methods.
\end{itemize}

At the beginning of the release candidate phase of a release, maintainers of
failing module dashboard builds will be contacted. If a module's dashboard
submission is still failing at the last release candidate tagging, it will be
removed before the final release.

Module names must be \textbf{unique}.

At no time in the future should a module in the main repository depend on a
Remote Module.

\subsection{Procedure for Adding a Remote Module}
\label{subsec:ProcedureAddingRemoteModules}

The repository
\begin{center}
  \url{https://github.com/InsightSoftwareConsortium/ITKModuleTemplate}
\end{center}

provides a useful template to be used as a starting point for a new ITK module.

The procedure to publish a new module in ITK is summarized as follows:
\begin{enumerate}
\item Publish an open access article describing the module in an online, open
  access journal like The Insight Journal.
\item Push a topic to the ITK GitHub repository (see
  Section~\ref{sec:GitRepository} on page~\pageref{sec:GitRepository} that
  adds a file named
  \code{Modules/Remote/<module name>.remote.cmake}. This file must have the
  following:
  \begin{enumerate}
    \item Dashboard maintainer name and email in the comments.
    \item A call to the \code{itk\_fetch\_module} CMake function (documented in
      \code{CMake/ITKModuleRemote.cmake}) whose arguments are:
      \begin{enumerate}
      \item The name of the remote module. Note that in each
        \code{<remote module name>.remote.cmake}, the first argument of the function
        \code{itk\_fetch\_module()} is the name of the remote module, and it has to be
        consistent with the module name defined in the corresponding
        \code{<remote module name>.remote.cmake}. To better distinguish the remote
        modules from the internal ITK modules, the names of the remote modules should
        \textbf{NOT} contain the ``ITK'' string prefix.
      \item A short description of the module with the handle to the open access
        article.
      \item URLs describing the location and version of the code to download. The
        version should be a specific hash.
      \end{enumerate}
  \end{enumerate}
\end{enumerate}

After the Remote Module has experienced sufficient testing, and community
members express broad interest in the contribution, the submitter can then move
the contribution into the ITK repository via GitHub code review.

It is possible but not recommended to directly push a module to GitHub for
review without submitting to Insight Journal first.
